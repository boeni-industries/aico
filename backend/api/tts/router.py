"""
TTS API Router

REST API endpoints for text-to-speech synthesis via modelservice.
"""

# IMMEDIATE DEBUG - Before any imports
print("=" * 100)
print("üî•üî•üî• TTS ROUTER.PY BEING LOADED - BEFORE IMPORTS")
print("=" * 100)

from typing import Annotated
from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import StreamingResponse
from aico.core.logging import get_logger
from aico.core.topics import AICOTopics
from aico.proto.aico_modelservice_pb2 import TtsRequest, TtsStreamChunk
from backend.api.conversation.dependencies import get_current_user
from .schemas import TtsSynthesizeRequest

logger = get_logger("aico.api.tts", "router")

# MODULE LOAD DEBUG - This should print on every module reload
print("=" * 80)
print("üî• TTS ROUTER MODULE LOADED - VERSION 3 - ENVELOPE UNPACKING")
print("=" * 80)
import sys
print(f"Module path: {__file__}")
print(f"Python: {sys.version}")
print("=" * 80)

router = APIRouter()


async def get_message_bus_client(request: Request):
    """Get message bus client from service container"""
    if not hasattr(request.app.state, 'service_container'):
        raise HTTPException(
            status_code=500,
            detail="Service container not available"
        )
    
    container = request.app.state.service_container
    message_bus_plugin = container.get_service("message_bus_plugin")
    
    if not message_bus_plugin or not hasattr(message_bus_plugin, 'message_bus_host'):
        raise HTTPException(
            status_code=500,
            detail="Message bus plugin not available"
        )
    
    if not message_bus_plugin.message_bus_host:
        raise HTTPException(
            status_code=500,
            detail="Message bus host not initialized"
        )
    
    # Register TTS API module
    try:
        client = await message_bus_plugin.register_module(
            "tts_api",
            [AICOTopics.MODELSERVICE_TTS_STREAM]
        )
        return client
    except Exception as e:
        if "already registered" in str(e).lower():
            logger.debug("Module tts_api already registered")
            # Try to get existing client
            client = await message_bus_plugin.register_module(
                "tts_api",
                [AICOTopics.MODELSERVICE_TTS_STREAM]
            )
            return client
        raise HTTPException(status_code=500, detail=f"Failed to register message bus client: {e}")


@router.post("/synthesize")
async def synthesize_tts(
    request_data: TtsSynthesizeRequest,
    user: Annotated[dict, Depends(get_current_user)],
    bus_client: Annotated[object, Depends(get_message_bus_client)]
):
    """
    Synthesize text to speech and stream audio.
    
    **Authentication required:** Bearer token
    
    Streams WAV audio chunks as they're generated by the modelservice.
    Audio format: WAV, 22050 Hz, mono, 16-bit PCM.
    
    **Parameters:**
    - `text`: Text to synthesize (1-5000 characters)
    - `language`: Language code (empty = auto-detect, default: auto-detect)
    - `speed`: Speech speed multiplier 0.5-2.0 (default: 1.0)
    - `voice`: Optional custom voice identifier
    
    **Language Detection:**
    - Backend automatically detects language from text (FastText, 95% accuracy)
    - Supports 217 languages
    - Leave `language` empty for automatic detection (recommended)
    """
    print("=" * 100)
    print("üé§ TTS ENDPOINT CALLED - NEW CODE V3")
    print(f"Request data: {request_data}")
    print("=" * 100)
    
    try:
        logger.info(f"üé§ TTS request (NEW CODE v2): {len(request_data.text)} chars, language: {request_data.language}")
        print(f"üé§ Logger called successfully")
        
        # Create TTS request protobuf
        tts_request = TtsRequest(
            text=request_data.text,
            language=request_data.language,
            speed=request_data.speed
        )
        
        if request_data.voice:
            tts_request.voice = request_data.voice
        
        # Send request to modelservice (publish expects protobuf object, not bytes)
        print(f"üì§ [TTS ROUTER] Publishing TTS request to topic: {AICOTopics.MODELSERVICE_TTS_REQUEST}")
        print(f"üì§ [TTS ROUTER] Request: text={len(tts_request.text)} chars, language={tts_request.language}")
        await bus_client.publish(
            AICOTopics.MODELSERVICE_TTS_REQUEST,
            tts_request  # Pass the protobuf object directly
        )
        print(f"‚úÖ [TTS ROUTER] TTS request published successfully")
        
        # Stream audio chunks as they arrive
        async def audio_stream():
            """Generator that yields audio chunks from modelservice"""
            subscription_id = None
            try:
                print("üéµ [TTS ROUTER V3] Starting audio_stream generator")
                logger.info("üéµ [TTS ROUTER V3] Starting audio_stream generator")
                
                # Subscribe to TTS stream with callback
                all_audio_chunks = []  # Buffer ALL chunks before sending
                streaming_complete = False
                detected_sample_rate = None
                
                async def handle_tts_chunk(envelope):
                    nonlocal streaming_complete, detected_sample_rate, all_audio_chunks
                    try:
                        import time
                        receive_time = time.time()
                        print(f"üì¶ [TTS ROUTER V3] Received envelope at {receive_time}: {type(envelope)}")
                        logger.info(f"üì¶ [TTS ROUTER V3] Received envelope: {type(envelope)}")
                        
                        # Unpack TTS chunk from protobuf envelope
                        unpack_start = time.time()
                        chunk = TtsStreamChunk()
                        envelope.any_payload.Unpack(chunk)
                        unpack_time = time.time() - unpack_start
                        
                        print(f"‚úÖ [TTS ROUTER V3] Unpacked chunk in {unpack_time*1000:.2f}ms - is_final={chunk.is_final}, has_audio={len(chunk.audio_data) if chunk.audio_data else 0} bytes, sample_rate={chunk.sample_rate}, error={chunk.error}")
                        logger.info(f"‚úÖ [TTS ROUTER V3] Successfully unpacked chunk - is_final={chunk.is_final}, has_audio={len(chunk.audio_data) if chunk.audio_data else 0} bytes, sample_rate={chunk.sample_rate}")
                        
                        # Track sample rate from first chunk
                        if detected_sample_rate is None and chunk.sample_rate > 0:
                            detected_sample_rate = chunk.sample_rate
                            print(f"üîä [TTS ROUTER] Detected sample rate: {detected_sample_rate} Hz")
                        
                        # Check for errors
                        if chunk.error:
                            print(f"‚ùå [TTS ROUTER V3] TTS synthesis error: {chunk.error}")
                            logger.error(f"TTS synthesis error: {chunk.error}")
                            streaming_complete = True
                            return True
                        
                        # Check if final chunk
                        if chunk.is_final:
                            print(f"üèÅ [TTS ROUTER V3] Final chunk received - total audio chunks buffered: {len(all_audio_chunks)}")
                            logger.info("‚úÖ TTS synthesis complete")
                            streaming_complete = True
                            return False  # Don't stop subscription yet - let loop finish yielding
                        
                        # Store audio data in buffer
                        if chunk.audio_data:
                            all_audio_chunks.append(chunk.audio_data)
                            print(f"üíæ [TTS ROUTER V3] Buffered audio chunk #{len(all_audio_chunks)} ({len(chunk.audio_data)} bytes)")
                        else:
                            print(f"‚ö†Ô∏è [TTS ROUTER V3] Received chunk with no audio data")
                        
                        return False  # Continue listening
                        
                    except Exception as e:
                        logger.error(f"Error processing TTS chunk: {e}")
                        streaming_complete = True
                        return True
                
                # Subscribe to TTS stream
                print(f"üéß [TTS ROUTER V3] Subscribing to {AICOTopics.MODELSERVICE_TTS_STREAM}")
                subscription_id = await bus_client.subscribe(AICOTopics.MODELSERVICE_TTS_STREAM, handle_tts_chunk)
                print(f"üéß [TTS ROUTER V3] Subscribed with ID: {subscription_id}")
                
                # Wait for all chunks to be buffered
                import asyncio
                import time
                import struct
                loop_start = time.time()
                print("‚è≥ [TTS ROUTER] Waiting for all audio chunks to be buffered...")
                
                while not streaming_complete:
                    await asyncio.sleep(0.01)  # Wait for synthesis to complete
                
                # Now create complete WAV file with correct size
                if not all_audio_chunks:
                    print("‚ö†Ô∏è [TTS ROUTER] No audio chunks received!")
                    return
                
                # Concatenate all audio data
                print(f"üîß [TTS ROUTER] Concatenating {len(all_audio_chunks)} audio chunks...")
                audio_data = b''.join(all_audio_chunks)
                data_size = len(audio_data)
                print(f"‚úÖ [TTS ROUTER] Total audio data: {data_size} bytes")
                
                # Create proper WAV header with correct sizes
                if detected_sample_rate is None:
                    detected_sample_rate = 22050  # Fallback
                    print(f"‚ö†Ô∏è [TTS ROUTER] No sample rate detected, using fallback: {detected_sample_rate} Hz")
                
                sample_rate = detected_sample_rate
                channels = 1
                bits_per_sample = 16
                byte_rate = sample_rate * channels * bits_per_sample // 8
                block_align = channels * bits_per_sample // 8
                file_size = 36 + data_size  # Total file size - 8
                
                wav_header = struct.pack('<4sI4s4sIHHIIHH4sI',
                    b'RIFF',
                    file_size,  # Correct file size
                    b'WAVE',
                    b'fmt ',
                    16,  # fmt chunk size
                    1,   # PCM format
                    channels,
                    sample_rate,
                    byte_rate,
                    block_align,
                    bits_per_sample,
                    b'data',
                    data_size  # Correct data size
                )
                
                print(f"üìù [TTS ROUTER] Created WAV header: {sample_rate} Hz, {channels} ch, {bits_per_sample} bit, {data_size} bytes data")
                
                # Yield complete WAV file (header + data)
                yield wav_header
                yield audio_data
                
                loop_total = time.time() - loop_start
                print(f"‚è±Ô∏è [TTS ROUTER TIMING] Total processing time: {loop_total*1000:.2f}ms")
                print(f"‚úÖ [TTS ROUTER] Complete WAV file sent ({len(wav_header) + data_size} bytes total)")
                        
            except Exception as e:
                logger.error(f"Error streaming TTS audio: {e}")
                raise
            finally:
                # Clean up subscription
                if subscription_id:
                    try:
                        await bus_client.unsubscribe(subscription_id)
                        print(f"üßπ [TTS ROUTER V3] Unsubscribed from TTS stream (ID: {subscription_id})")
                    except Exception as e:
                        logger.error(f"Error unsubscribing from TTS stream: {e}")
        
        return StreamingResponse(
            audio_stream(),
            media_type="audio/wav",
            headers={
                "Content-Disposition": "inline",
                "Cache-Control": "no-cache"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        tb = traceback.format_exc()
        print("=" * 100)
        print("‚ùå TTS SYNTHESIS EXCEPTION:")
        print(tb)
        print("=" * 100)
        logger.error(f"TTS synthesis failed: {e}")
        logger.error(f"Traceback: {tb}")
        raise HTTPException(
            status_code=500,
            detail=f"TTS synthesis failed: {str(e)}"
        )
