"""
TTS API Router

REST API endpoints for text-to-speech synthesis via modelservice.
"""

from typing import Annotated
from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import StreamingResponse
from aico.core.logging import get_logger
from aico.core.topics import AICOTopics
from aico.proto.aico_modelservice_pb2 import TtsRequest, TtsStreamChunk
from backend.api.conversation.dependencies import get_current_user
from .schemas import TtsSynthesizeRequest

logger = get_logger("aico.api.tts", "router")

router = APIRouter()


async def get_message_bus_client(request: Request):
    """Get message bus client from service container"""
    if not hasattr(request.app.state, 'service_container'):
        raise HTTPException(
            status_code=500,
            detail="Service container not available"
        )
    
    container = request.app.state.service_container
    message_bus_plugin = container.get_service("message_bus_plugin")
    
    if not message_bus_plugin or not hasattr(message_bus_plugin, 'message_bus_host'):
        raise HTTPException(
            status_code=500,
            detail="Message bus plugin not available"
        )
    
    if not message_bus_plugin.message_bus_host:
        raise HTTPException(
            status_code=500,
            detail="Message bus host not initialized"
        )
    
    # Register TTS API module
    try:
        client = await message_bus_plugin.register_module(
            "tts_api",
            [AICOTopics.MODELSERVICE_TTS_STREAM]
        )
        return client
    except Exception as e:
        if "already registered" in str(e).lower():
            logger.debug("Module tts_api already registered")
            # Try to get existing client
            client = await message_bus_plugin.register_module(
                "tts_api",
                [AICOTopics.MODELSERVICE_TTS_STREAM]
            )
            return client
        raise HTTPException(status_code=500, detail=f"Failed to register message bus client: {e}")


@router.post("/synthesize")
async def synthesize_tts(
    request_data: TtsSynthesizeRequest,
    user: Annotated[dict, Depends(get_current_user)],
    bus_client: Annotated[object, Depends(get_message_bus_client)]
):
    """
    Synthesize text to speech and stream audio.
    
    **Authentication required:** Bearer token
    
    Streams WAV audio chunks as they're generated by the modelservice.
    Audio format: WAV, 22050 Hz, mono, 16-bit PCM.
    
    **Parameters:**
    - `text`: Text to synthesize (1-5000 characters)
    - `language`: ISO 639-1 language code (default: "en")
    - `speed`: Speech speed multiplier 0.5-2.0 (default: 1.0)
    - `voice`: Optional custom voice identifier
    
    **Supported Languages:**
    en, de, es, fr, it, pt, pl, tr, ru, nl, cs, ar, zh, ja, hu, ko, hi
    """
    try:
        logger.info(f"ðŸŽ¤ TTS request: {len(request_data.text)} chars, language: {request_data.language}")
        
        # Create TTS request protobuf
        tts_request = TtsRequest(
            text=request_data.text,
            language=request_data.language,
            speed=request_data.speed
        )
        
        if request_data.voice:
            tts_request.voice = request_data.voice
        
        # Serialize request
        request_bytes = tts_request.SerializeToString()
        
        # Send request to modelservice
        await bus_client.publish(
            AICOTopics.MODELSERVICE_TTS_REQUEST,
            request_bytes
        )
        
        # Stream audio chunks as they arrive
        async def audio_stream():
            """Generator that yields audio chunks from modelservice"""
            try:
                # Subscribe to TTS stream
                async for message in bus_client.subscribe_stream(AICOTopics.MODELSERVICE_TTS_STREAM):
                    # Parse TTS chunk
                    chunk = TtsStreamChunk()
                    chunk.ParseFromString(message)
                    
                    # Check for errors
                    if chunk.error:
                        logger.error(f"TTS synthesis error: {chunk.error}")
                        break
                    
                    # Check if final chunk
                    if chunk.is_final:
                        logger.info("âœ… TTS synthesis complete")
                        break
                    
                    # Yield audio data
                    if chunk.audio_data:
                        yield chunk.audio_data
                        
            except Exception as e:
                logger.error(f"Error streaming TTS audio: {e}")
                raise
        
        return StreamingResponse(
            audio_stream(),
            media_type="audio/wav",
            headers={
                "Content-Disposition": "inline",
                "Cache-Control": "no-cache"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"TTS synthesis failed: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"TTS synthesis failed: {str(e)}"
        )
