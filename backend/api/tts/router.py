"""
TTS API Router

REST API endpoints for text-to-speech synthesis via modelservice.
"""

# IMMEDIATE DEBUG - Before any imports
print("=" * 100)
print("üî•üî•üî• TTS ROUTER.PY BEING LOADED - BEFORE IMPORTS")
print("=" * 100)

from typing import Annotated
from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import StreamingResponse
from aico.core.logging import get_logger
from aico.core.topics import AICOTopics
from aico.proto.aico_modelservice_pb2 import TtsRequest, TtsStreamChunk
from backend.api.conversation.dependencies import get_current_user
from .schemas import TtsSynthesizeRequest

logger = get_logger("aico.api.tts", "router")

# MODULE LOAD DEBUG - This should print on every module reload
print("=" * 80)
print("üî• TTS ROUTER MODULE LOADED - VERSION 3 - ENVELOPE UNPACKING")
print("=" * 80)
import sys
print(f"Module path: {__file__}")
print(f"Python: {sys.version}")
print("=" * 80)

router = APIRouter()


async def get_message_bus_client(request: Request):
    """Get message bus client from service container"""
    if not hasattr(request.app.state, 'service_container'):
        raise HTTPException(
            status_code=500,
            detail="Service container not available"
        )
    
    container = request.app.state.service_container
    message_bus_plugin = container.get_service("message_bus_plugin")
    
    if not message_bus_plugin or not hasattr(message_bus_plugin, 'message_bus_host'):
        raise HTTPException(
            status_code=500,
            detail="Message bus plugin not available"
        )
    
    if not message_bus_plugin.message_bus_host:
        raise HTTPException(
            status_code=500,
            detail="Message bus host not initialized"
        )
    
    # Register TTS API module
    try:
        client = await message_bus_plugin.register_module(
            "tts_api",
            [AICOTopics.MODELSERVICE_TTS_STREAM]
        )
        return client
    except Exception as e:
        if "already registered" in str(e).lower():
            logger.debug("Module tts_api already registered")
            # Try to get existing client
            client = await message_bus_plugin.register_module(
                "tts_api",
                [AICOTopics.MODELSERVICE_TTS_STREAM]
            )
            return client
        raise HTTPException(status_code=500, detail=f"Failed to register message bus client: {e}")


@router.post("/synthesize")
async def synthesize_tts(
    request_data: TtsSynthesizeRequest,
    user: Annotated[dict, Depends(get_current_user)],
    bus_client: Annotated[object, Depends(get_message_bus_client)]
):
    """
    Synthesize text to speech and stream audio.
    
    **Authentication required:** Bearer token
    
    Streams WAV audio chunks as they're generated by the modelservice.
    Audio format: WAV, 22050 Hz, mono, 16-bit PCM.
    
    **Parameters:**
    - `text`: Text to synthesize (1-5000 characters)
    - `language`: ISO 639-1 language code (default: "en")
    - `speed`: Speech speed multiplier 0.5-2.0 (default: 1.0)
    - `voice`: Optional custom voice identifier
    
    **Supported Languages:**
    en, de, es, fr, it, pt, pl, tr, ru, nl, cs, ar, zh, ja, hu, ko, hi
    """
    print("=" * 100)
    print("üé§ TTS ENDPOINT CALLED - NEW CODE V3")
    print(f"Request data: {request_data}")
    print("=" * 100)
    
    try:
        logger.info(f"üé§ TTS request (NEW CODE v2): {len(request_data.text)} chars, language: {request_data.language}")
        print(f"üé§ Logger called successfully")
        
        # Create TTS request protobuf
        tts_request = TtsRequest(
            text=request_data.text,
            language=request_data.language,
            speed=request_data.speed
        )
        
        if request_data.voice:
            tts_request.voice = request_data.voice
        
        # Send request to modelservice (publish expects protobuf object, not bytes)
        print(f"üì§ [TTS ROUTER] Publishing TTS request to topic: {AICOTopics.MODELSERVICE_TTS_REQUEST}")
        print(f"üì§ [TTS ROUTER] Request: text={len(tts_request.text)} chars, language={tts_request.language}")
        await bus_client.publish(
            AICOTopics.MODELSERVICE_TTS_REQUEST,
            tts_request  # Pass the protobuf object directly
        )
        print(f"‚úÖ [TTS ROUTER] TTS request published successfully")
        
        # Stream audio chunks as they arrive
        async def audio_stream():
            """Generator that yields audio chunks from modelservice"""
            subscription_id = None
            try:
                print("üéµ [TTS ROUTER V3] Starting audio_stream generator")
                logger.info("üéµ [TTS ROUTER V3] Starting audio_stream generator")
                
                # Subscribe to TTS stream with callback
                chunks_received = []
                streaming_complete = False
                
                async def handle_tts_chunk(envelope):
                    nonlocal streaming_complete
                    try:
                        import time
                        receive_time = time.time()
                        print(f"üì¶ [TTS ROUTER V3] Received envelope at {receive_time}: {type(envelope)}")
                        logger.info(f"üì¶ [TTS ROUTER V3] Received envelope: {type(envelope)}")
                        
                        # Unpack TTS chunk from protobuf envelope
                        unpack_start = time.time()
                        chunk = TtsStreamChunk()
                        envelope.any_payload.Unpack(chunk)
                        unpack_time = time.time() - unpack_start
                        
                        print(f"‚úÖ [TTS ROUTER V3] Unpacked chunk in {unpack_time*1000:.2f}ms - is_final={chunk.is_final}, has_audio={len(chunk.audio_data) if chunk.audio_data else 0} bytes, error={chunk.error}")
                        logger.info(f"‚úÖ [TTS ROUTER V3] Successfully unpacked chunk - is_final={chunk.is_final}, has_audio={len(chunk.audio_data) if chunk.audio_data else 0} bytes")
                        
                        # Check for errors
                        if chunk.error:
                            print(f"‚ùå [TTS ROUTER V3] TTS synthesis error: {chunk.error}")
                            logger.error(f"TTS synthesis error: {chunk.error}")
                            streaming_complete = True
                            return True
                        
                        # Check if final chunk
                        if chunk.is_final:
                            print(f"üèÅ [TTS ROUTER V3] Final chunk received - total audio chunks: {len(chunks_received)}")
                            logger.info("‚úÖ TTS synthesis complete")
                            streaming_complete = True
                            return False  # Don't stop subscription yet - let loop finish yielding
                        
                        # Store audio data
                        if chunk.audio_data:
                            chunks_received.append(chunk.audio_data)
                            print(f"üíæ [TTS ROUTER V3] Stored audio chunk #{len(chunks_received)} ({len(chunk.audio_data)} bytes)")
                        else:
                            print(f"‚ö†Ô∏è [TTS ROUTER V3] Received chunk with no audio data")
                        
                        return False  # Continue listening
                        
                    except Exception as e:
                        logger.error(f"Error processing TTS chunk: {e}")
                        streaming_complete = True
                        return True
                
                # Subscribe to TTS stream
                print(f"üéß [TTS ROUTER V3] Subscribing to {AICOTopics.MODELSERVICE_TTS_STREAM}")
                subscription_id = await bus_client.subscribe(AICOTopics.MODELSERVICE_TTS_STREAM, handle_tts_chunk)
                print(f"üéß [TTS ROUTER V3] Subscribed with ID: {subscription_id}")
                
                # Wait for chunks and yield them
                import asyncio
                import time
                loop_start = time.time()
                iteration = 0
                total_bytes_yielded = 0
                while not streaming_complete:
                    iteration += 1
                    if chunks_received:
                        yield_start = time.time()
                        print(f"üîÑ [TTS ROUTER V3] Iteration {iteration}: Yielding {len(chunks_received)} chunks")
                        # Yield all accumulated chunks
                        for i, audio_data in enumerate(chunks_received):
                            print(f"üì§ [TTS ROUTER V3] Yielding chunk {i+1}/{len(chunks_received)} ({len(audio_data)} bytes)")
                            yield audio_data
                            total_bytes_yielded += len(audio_data)
                        yield_time = time.time() - yield_start
                        print(f"‚è±Ô∏è [TTS ROUTER TIMING] Yielded {len(chunks_received)} chunks in {yield_time*1000:.2f}ms")
                        chunks_received.clear()
                    else:
                        if iteration % 100 == 0:  # Log every 100 iterations to avoid spam
                            print(f"‚è≥ [TTS ROUTER V3] Iteration {iteration}: Waiting for chunks... (streaming_complete={streaming_complete})")
                    await asyncio.sleep(0.01)  # Small delay to allow chunks to accumulate
                
                # Yield any remaining chunks after streaming_complete
                if chunks_received:
                    yield_start = time.time()
                    print(f"üîÑ [TTS ROUTER V3] Final yield: {len(chunks_received)} remaining chunks")
                    for i, audio_data in enumerate(chunks_received):
                        print(f"üì§ [TTS ROUTER V3] Yielding final chunk {i+1}/{len(chunks_received)} ({len(audio_data)} bytes)")
                        yield audio_data
                        total_bytes_yielded += len(audio_data)
                    yield_time = time.time() - yield_start
                    print(f"‚è±Ô∏è [TTS ROUTER TIMING] Final yield: {len(chunks_received)} chunks in {yield_time*1000:.2f}ms")
                    chunks_received.clear()
                
                loop_total = time.time() - loop_start
                print(f"‚è±Ô∏è [TTS ROUTER TIMING] Total loop time: {loop_total*1000:.2f}ms ({total_bytes_yielded} bytes yielded)")
                print(f"üé¨ [TTS ROUTER V3] Streaming loop ended - streaming_complete={streaming_complete}")
                        
            except Exception as e:
                logger.error(f"Error streaming TTS audio: {e}")
                raise
            finally:
                # Clean up subscription
                if subscription_id:
                    try:
                        await bus_client.unsubscribe(subscription_id)
                        print(f"üßπ [TTS ROUTER V3] Unsubscribed from TTS stream (ID: {subscription_id})")
                    except Exception as e:
                        logger.error(f"Error unsubscribing from TTS stream: {e}")
        
        return StreamingResponse(
            audio_stream(),
            media_type="audio/wav",
            headers={
                "Content-Disposition": "inline",
                "Cache-Control": "no-cache"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        tb = traceback.format_exc()
        print("=" * 100)
        print("‚ùå TTS SYNTHESIS EXCEPTION:")
        print(tb)
        print("=" * 100)
        logger.error(f"TTS synthesis failed: {e}")
        logger.error(f"Traceback: {tb}")
        raise HTTPException(
            status_code=500,
            detail=f"TTS synthesis failed: {str(e)}"
        )
